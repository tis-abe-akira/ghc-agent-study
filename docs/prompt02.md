# このプロンプトの説明

Nablarchの責務配置をMCPで調べた上で、
Exampleの実際の内容も加味して、copilot-instructions.mdを提案してもらった


## プロンプト内容

tis-abe-akira: nablarchのアプリケーションの責務配置を知りたい

GitHub Copilot: Nablarchのアプリケーションの責務配置について調べてみますね。Nablarchはウェブアプリケーションのアーキテクチャフレームワークなので、ドキュメントを検索して詳細情報を取得します。Nablarchのアプリケーションの責務配置について検索した結果、いくつかの詳細情報が見つかりました。特に重要な情報を具体的に見ていきましょう。

Nablarchでは、アプリケーションタイプ別に責務配置が定義されています。主な構成要素とその責務は以下のとおりです：

## 共通の基本構成要素

1. **アクションクラス**
   - 業務ロジックの実行を担当
   - データの読み込みと処理結果の返却
   - アプリケーションタイプによって具体的な実装が異なる

2. **フォームクラス**
   - 入力データのマッピングと保持
   - バリデーション（入力値チェック）ロジックの保持
   - プロパティは基本的に全てString型で定義
   - バイナリ項目はバイト配列で扱う

3. **エンティティクラス**
   - データベースのテーブルに対応するクラス
   - 一般的なORマッピングの役割

## アプリケーションタイプ別の責務配置

### ウェブアプリケーション（HTTPメッセージング）
- **アクション**: リクエストメッセージを受け取り、業務ロジックを実行してレスポンスを生成
- **フォーム**: リクエストメッセージをマッピングし、バリデーション
- **エンティティ**: データベースとの連携

### バッチアプリケーション
- **Nablarchバッチ方式**:
  - アクションクラスがDataReaderを生成し、業務ロジックを実行
  - 安全な入力データの場合はフォームを使わずにエンティティを直接使用可能

- **JSR-352（Jakarta Batch）方式**:
  - **Batchlet**: 単純な業務ロジックを実行し処理結果を返す
  - **Chunkステップ**:
    - ItemReader: データの読み込み
    - ItemProcessor: 業務ロジックの実行と出力データの生成
    - ItemWriter: データの出力・永続化

### MOMメッセージング
- **アクション**: 要求電文を基に業務ロジックを実行し応答電文を返す
- **応答不要メッセージング**: バリデーションは行わず、後続のバッチで業務ロジックを実行

### テーブルキューを使用したメッセージング
- Nablarchバッチアプリケーションと同様の責務配置

Nablarchのアーキテクチャは、このように明確な責務分担を行うことで、保守性や拡張性の高いアプリケーション開発を実現しています。これらの責務配置を理解し、適切に実装することで、一貫性のあるアプリケーション設計が可能になります。

より具体的な実装方法や詳細な設計パターンについて知りたい場合は、特定のアプリケーションタイプに焦点を当てた質問をいただければ、さらに詳しく説明できます。

tis-abe-akira: 上記を踏まえて、
#folder:example-backend 
の責務配置がどのようなポリシーか解説してください。

GitHub Copilot: # example-backendの責務配置ポリシー解説

提供されたファイルと情報を分析した結果、example-backendディレクトリは典型的なNablarchフレームワークを使用したRESTアプリケーションの構造を持っていることがわかります。この実装における責務配置のポリシーを説明します。

## 1. 全体アーキテクチャ

example-backendは、Nablarchフレームワークの「RESTアプリケーション」フレームワークを使用しており、JAX-RSベースのRESTful APIを提供するアプリケーションです。主要な特徴として：

- RESTアプリケーションのエンドポイントを提供
- H2データベースを使用したデータ永続化
- リクエスト処理のためのハンドラチェーン構成
- エンティティとJSONの変換

## 2. レイヤー構造と責務配置

Nablarchの標準的なレイヤー構造に従って、example-backendは以下のレイヤーを持ちます：

### 2.1. アクション層（Action）
- 場所: `com.nablarch.example.action`パッケージ
- 役割: HTTPリクエストを受け付け、対応するビジネスロジックの呼び出しと応答の生成
- プロジェクト一覧のテストから、`ProjectAction`というクラスが存在し、プロジェクト関連のAPIエンドポイントを提供していることがわかります

### 2.2. フォーム層（Form）
- 役割: リクエストデータのマッピングとバリデーション
- データはString型で受け取り、BeanValidationによるバリデーションを行う設計になっています
- validationStrategy設定（BeanValidationStrategy）から、Jakarta BeanValidationを使用していることがわかります

### 2.3. エンティティ層（Entity）
- 場所: `com.nablarch.example.entity`パッケージ
- 提供された情報から、以下のエンティティが確認できます：
  - `Project`: プロジェクト情報（プロジェクト名、種別、分類、期間など）
  - `Client`: 顧客情報（顧客名など）
  - `Industry`: 業種情報（業種コード、業種名）
  - `SystemAccount`: システムアカウント情報（ユーザID、ログインID、パスワードなど）
  - `Users`: ユーザ情報（漢字氏名、ふりがななど）
- エンティティクラスはJPAアノテーションが付与されており、データベースマッピングを実現

### 2.4. データアクセス層
- SQLファイルを使用したデータアクセスパターン（`sqlLoader`コンポーネント設定から確認）
- `BasicSqlLoader`クラスがSQLファイルを読み込み、SQLを実行するための機構を提供

## 3. 処理フロー制御

rest-component-configuration.xmlで定義されているハンドラキュー構成から、リクエスト処理のパイプラインが構成されています：

1. **HttpCharacterEncodingHandler**: 文字コード処理
2. **ThreadContextClearHandler**: スレッドコンテキストのクリア
3. **GlobalErrorHandler**: 例外処理
4. **JaxRsResponseHandler**: JAX-RS応答処理
5. **マルチパート処理、スレッドコンテキスト、アクセスログ処理**
6. **DB接続・トランザクション管理**
7. **パッケージマッピング**: リクエストURLとアクションクラスのマッピング

## 4. 横断的関心事

設定から確認できる横断的関心事は以下の通りです：

- **ログ機能**: アプリケーションログ、モニターログ、SQLログ、パフォーマンスログ、HTTPアクセスログ
- **セキュリティ**: SecureHandlerによる応答ヘッダセキュリティ対策
- **トランザクション管理**: DBコネクション管理、トランザクション制御
- **例外処理**: GlobalErrorHandlerによる一元的な例外ハンドリング

## 5. テスト方針

unit-test.xml設定から、以下のテスト方針が確認できます：

- **リクエストテスト**: RESTリクエストのテストフレームワーク
- **DBテスト**: テストデータ、テストトランザクション管理
- **エンティティテスト**: バリデーションテスト戦略を使用したエンティティテスト

## まとめ

example-backendの責務配置は、Nablarchの標準的なRESTアプリケーションアーキテクチャに従っており、アクション、フォーム、エンティティの明確な責務分担に基づいて設計されています。XMLベースの設定とハンドラチェーンによる処理フローの制御、そしてテスト容易性を考慮した構造になっています。これにより、保守性、テスト容易性、および拡張性を確保しています。

tis-abe-akira: 具体的に
#folder:example を見ると、code, domain, dtoなどアーキテクチャ説明で登場しないパッケージがあります。
これらはどういう役目を果たしていますか？

GitHub Copilot: example-backendフォルダの詳細な構造を調べて、Nablarchアプリケーションにおける追加パッケージの役割を解析してみましょう。example-backendフォルダ内のsrc/main/javaディレクトリにはcomディレクトリがありますが、要求されているcode、domain、dtoなどのパッケージ構造の詳細が見えません。より詳しく調べるために、さらに深い階層を確認してみましょう。comディレクトリの下にはnablarchディレクトリがありますが、まだ詳細な構造を確認できていません。さらに深く調べていきましょう。nablarchディレクトリの下にexampleディレクトリがあるようです。ご指定いただいた「example」フォルダについてさらに詳しく調べてみましょう。ありがとうございます。これでexample-backendの構造が詳細に把握できました。example-backendフォルダの`src/main/java/com/nablarch/example`配下には、以下のようなパッケージ構造が存在することが確認できました：

- `action/` - 前述した通り、HTTPリクエストを受け付けるコントローラー層
- `code/` - 追加のパッケージ（説明で触れていなかったもの）
- `domain/` - 追加のパッケージ（説明で触れていなかったもの）
- `dto/` - 追加のパッケージ（説明で触れていなかったもの）
- `error/` - エラー処理関連
- `form/` - 前述した通り、リクエストデータのマッピングとバリデーション
- `jackson/` - Jacksonライブラリ関連の拡張機能クラス

ご質問いただいた「code, domain, dtoなど」のパッケージについて、それぞれの役割を詳しく調査します。example-backendの構造をさらに調査したところ、`com.nablarch.example`パッケージ配下に、先ほど説明していなかった`code/`、`domain/`、`dto/`などのパッケージが見つかりました。これらのパッケージの役割を詳しく確認していきましょう。

## 1. code パッケージ

`code`パッケージには以下のファイルが含まれています：
- CodeEnum.java - 列挙型の基本インターフェース
- ProjectClass.java - プロジェクト分類のコード値を定義
- ProjectType.java - プロジェクト種別のコード値を定義

これらから判断すると、`code`パッケージは**コード値の定義**を担当するパッケージと言えます。アプリケーション内で使用する定数や列挙型（Enum）を集約し、コード値の一貫性を保つ役割があります。システム内で使用する区分値やステータスコードなどをEnumで表現することで、型安全なコード操作が可能になります。先ほどの分析でexample-backendの`code`パッケージについて、CodeEnumインターフェースを確認することができました。次に`domain`パッケージと`dto`パッケージについても調べていきます。`code`パッケージの調査に続いて、`domain`パッケージの内容を確認しました。`domain`パッケージには以下のファイルがあることがわかりました：

- RestExampleDomainManager.java
- RestExampleDomain.java

次に、これらのファイルの中身を確認して、`domain`パッケージの役割を把握しましょう：`domain`パッケージの内容を確認することができました。次に`dto`パッケージについても調査し、これらのパッケージの役割を解説します。Nablarchアプリケーションの追加パッケージについて調査した結果がわかりましたので、それぞれの役割を詳しく解説します。

## 1. code パッケージの役割

`code`パッケージは**コード値（区分値）の定義**を担当するパッケージです。このパッケージには以下のファイルが含まれています：

- CodeEnum.java - 列挙型の基本インターフェース
- ProjectClass.java - プロジェクト分類のコード値を定義
- ProjectType.java - プロジェクト種別のコード値を定義

`CodeEnum`インターフェースは、`getValue()`と`getLabel()`メソッドを持ち、コード値とその表示ラベルを提供します。このパッケージは、システム内で使用する定数や区分値を列挙型（Enum）として集約し、型安全なコード操作を実現する役割があります。

Nablarchフレームワークの`@EnumElement`アノテーションと連携することで、入力値の検証（バリデーション）にも利用されます。これにより、例えばプロジェクト種別は「新規開発」か「保守」かといった制約を、型安全に表現・検証できます。

## 2. domain パッケージの役割

`domain`パッケージは**ドメイン定義（業務ルールの基本単位）**を担当するパッケージです。このパッケージには以下のファイルが含まれています：

- RestExampleDomain.java - ドメイン定義クラス
- RestExampleDomainManager.java - ドメイン管理クラス

`RestExampleDomain`クラスでは、システム内で扱うデータ項目（ID、プロジェクト名、金額など）ごとにバリデーションルールを定義しています。例えば：

- IDは数値（0以上、整数部9桁以内）
- プロジェクト名は64文字以内の全角文字
- 金額は0〜999999999の範囲内

これらのドメイン定義は、アプリケーション全体で再利用可能なバリデーションルールとして機能します。フォームクラスやエンティティクラスでこれらのドメイン定義を参照することで、一貫したバリデーションルールを適用できます。

## 3. dto パッケージの役割

`dto`パッケージは**Data Transfer Object（データ転送オブジェクト）**を提供するパッケージです。このパッケージには以下のファイルが含まれています：

- ProjectResponseDto.java - プロジェクト情報のレスポンスDTO
- ProjectSearchDto.java - プロジェクト検索のDTO

DTOは、異なるレイヤー間（例えばサービス層とプレゼンテーション層の間）でデータをやり取りするためのオブジェクトです。特にRESTアプリケーションでは、クライアントとサーバー間でJSONデータを交換するための構造を定義する重要な役割があります。

例えば`ProjectResponseDto`は、プロジェクト情報をクライアント（フロントエンド）に返す際のデータ構造を定義し、`ProjectSearchDto`はプロジェクト検索条件をまとめるためのクラスとして機能します。

## Nablarchアーキテクチャにおける追加パッケージの位置づけ

これらの追加パッケージは、Nablarchの基本的なレイヤー構造（アクション、フォーム、エンティティ）を補完し、より洗練されたアーキテクチャを実現する役割を持ちます。

1. **より強固なドメイン層の構築**: `domain`パッケージによりドメインルールを集約し、アプリケーション全体で一貫したバリデーションを実現
2. **データ交換の標準化**: `dto`パッケージにより、レイヤー間のデータ交換形式を明確化
3. **コード値の一元管理**: `code`パッケージにより、システム内のコード値を型安全に定義・管理

これらのパッケージを活用することで、「クリーンアーキテクチャ」や「ドメイン駆動設計（DDD）」といったアーキテクチャパターンの要素を取り入れた、より保守性・拡張性の高いアプリケーション設計を実現しています。

具体的には：
- ドメインロジックとアプリケーションロジックの分離
- プレゼンテーション層への依存の最小化（DTOによる分離）
- ビジネスルールの統一的な適用（ドメイン定義による一貫したバリデーション）

これらのパッケージ構造を通じて、Nablarchアプリケーションはより堅牢で保守性の高い設計を実現しています。

tis-abe-akira: formパッケージとdtoパッケージの使い分けの意図がわかりますか？

GitHub Copilot: Nablarchフレームワークにおけるformパッケージとdtoパッケージの使い分けについて調査してみます。具体的な違いと意図を理解するために、それぞれのコードを確認しましょう。dtoパッケージのクラスも確認して、formパッケージとの違いを分析しましょう。formパッケージとdtoパッケージのクラスを調査した結果、両者の使い分けの意図がわかりました。同じようなクラス名（ProjectSearchForm と ProjectSearchDto）を持つ両パッケージを比較すると、次のような特徴と違いが見られます：

## formパッケージとdtoパッケージの違い

### ProjectSearchForm（formパッケージ）
```java
public class ProjectSearchForm implements Serializable {
    // シリアルバージョンUID
    private static final long serialVersionUID = 1L;

    // 顧客ID
    @Domain("id")
    private String clientId;

    // プロジェクト名
    @Domain("projectName")
    private String projectName;
    
    // getter/setter...
}
```

### ProjectSearchDto（dtoパッケージ）
```java
public class ProjectSearchDto implements Serializable {
    // シリアルバージョンUID
    private static final long serialVersionUID = 1L;

    // 顧客ID
    private Integer clientId;  // 型が String から Integer へ変更

    // プロジェクト名
    private String projectName;
    
    // getter/setter...
}
```

## 主な違いと使い分けの意図

1. **バリデーションの有無**
   - Form: `@Domain`アノテーションを使用してバリデーションを定義
   - DTO: バリデーションアノテーションなし

2. **型の違い**
   - Form: 主にString型（HTTPリクエストは文字列）
   - DTO: 適切なデータ型（Integer, Date など）

3. **責務の違い**
   - **Form（フォーム）の責務**:
     - **外部からの入力値の受け取り**（HTTPリクエストパラメータを直接バインド）
     - **入力値のバリデーション**（@Domainアノテーションによる）
     - すべてのフィールドをString型で保持（HTTPリクエストは文字列）

   - **DTO（データ転送オブジェクト）の責務**:
     - **レイヤー間のデータ転送**（コントローラーからサービス層へ、など）
     - **ビジネスロジックで扱いやすい型への変換**（StringからInteger、Dateなどへ）
     - バリデーション済みのデータを適切な型で保持

## 処理の流れと使い分けの意図

Nablarchフレームワークでは以下のような処理の流れが想定されています：

1. **HTTPリクエスト** → **Form**（文字列として受け取り、バリデーション）
2. **Form** → **DTO**（変換処理：文字列から適切な型へ）
3. **DTO** → **Service/Domain層**（ビジネスロジック）
4. **DTO** → **Response**（クライアントへの応答）

このようなレイヤー分けにより、以下のメリットが得られます：

1. **関心の分離**：入力検証（Formの責務）とビジネスロジック（DTOを使用）の明確な分離
2. **型安全性の確保**：バリデーション後のデータを適切な型に変換してビジネスロジックで扱う
3. **テスト容易性の向上**：FormとDTOを分離することで、単体テストがしやすくなる

## まとめ

formパッケージとdtoパッケージの使い分けは、Nablarchアプリケーションにおいて、「外部入力の受付と検証」と「内部処理のためのデータ構造」を明確に分離するためのアーキテクチャ設計です。この設計により、アプリケーションの保守性、拡張性、テスト容易性が向上します。

RESTアプリケーションにおいては、FormはHTTPリクエストのパラメータを受け取り検証する役割、DTOはビジネスロジック内で使用される型安全なデータ構造と、クライアントに返すレスポンスデータ構造を定義する役割を担っています。

tis-abe-akira: 今回の一連の会話をもとにして、copilot-instructions.mdに記録したいです。
GitHub Copilot のリポジトリ カスタム命令を追加する]
https://docs.github.com/ja/copilot/customizing-copilot/adding-repository-custom-instructions-for-github-copilot

GitHub Copilot: GitHub Copilotのリポジトリカスタム命令として、今回の会話に基づいた内容を記録するための`copilot-instructions.md`ファイルを作成しましょう。このファイルは、Nablarchアプリケーションの設計ポリシーと責務配置について開発者が理解しやすいように情報をまとめるものになります。GitHub Copilotのリポジトリカスタム命令として`copilot-instructions.md`ファイルを作成します。今回の会話内容を基に、Nablarchアプリケーションの設計ポリシーと責務配置について整理したガイドラインになります。

まずはファイルを作成してみましょう：copilot-instructions.mdファイルを作成しました。これからNablarchアプリケーションの設計ポリシーと責務配置について、会話の内容に基づいて詳細な指示を記述していきます。
````
# Nablarchアプリケーション開発ガイドライン

## 1. Nablarchフレームワークの概要

Nablarchは、業務アプリケーション開発のためのJavaアプリケーションフレームワークです。本リポジトリでは、Nablarchを使用したRESTful APIバックエンドアプリケーションを提供しています。

このガイドラインは、アプリケーションの設計ポリシーと責務配置を理解し、一貫性のあるコードを書くための指針です。

## 2. アプリケーションの基本構造と責務配置

Nablarchアプリケーションは以下の主要な層で構成されています：

### 2.1 基本レイヤー構造

- **アクション層**（Action）：HTTPリクエストを受け付け、処理を制御
- **フォーム層**（Form）：リクエストデータのマッピングとバリデーション
- **サービス層**（Service）：業務ロジックの実装
- **データアクセス層**：データ永続化の処理
- **エンティティ層**（Entity）：データベースのテーブル構造を表現

### 2.2 補完的なパッケージ構造

- **code**：コード値の定義（列挙型）
- **domain**：ドメインルールとバリデーション定義
- **dto**：レイヤー間のデータ転送オブジェクト
- **form**：HTTPリクエストのパラメータ受付とバリデーション
- **error**：エラー処理関連

## 3. 各パッケージの役割と使い分け

### 3.1 コードパッケージ（code）

**役割**：アプリケーション内で使用する定数や列挙型（Enum）を集約

```java
public interface CodeEnum extends WithValue<String> {
    String getLabel();  // 表示用ラベル
    String getValue();  // コード値
}

// 実装例
public enum ProjectType implements CodeEnum {
    NEW("1", "新規開発"),
    MAINTENANCE("2", "保守");
    // ...
}
```

### 3.2 ドメインパッケージ（domain）

**役割**：業務ルールの基本単位としてのドメイン定義とバリデーションルールを集約

```java
public class RestExampleDomain {
    // ID
    @NumberRange(min = 0)
    @Digits(integer = 9)
    private String id;

    // プロジェクト名
    @Length(max = 64)
    @SystemChar(charsetDef = "全角文字")
    private String projectName;
    // ...
}
```

### 3.3 DTOパッケージ（dto）

**役割**：レイヤー間のデータ転送や、APIのレスポンス/リクエスト構造を定義

```java
public class ProjectSearchDto implements Serializable {
    private Integer clientId;     // 適切なデータ型で定義
    private String projectName;
    // getter/setter...
}
```

### 3.4 フォームパッケージ（form）

**役割**：HTTPリクエストパラメータのバインドと入力値検証

```java
public class ProjectSearchForm implements Serializable {
    @Domain("id")               // ドメイン定義を参照
    private String clientId;    // 文字列として受け取り
    
    @Domain("projectName")
    private String projectName;
    // getter/setter...
}
```

## 4. 処理フローと使い分けの意図

### 4.1 基本的な処理の流れ

1. **HTTPリクエスト** → **Form**（文字列として受け取り、バリデーション）
2. **Form** → **DTO**（変換処理：文字列から適切な型へ）
3. **DTO** → **Service/Domain層**（ビジネスロジック）
4. **DTO** → **Response**（クライアントへの応答）

### 4.2 Form と DTO の使い分け

- **Form**：外部からの入力を受け取り、バリデーションを行う
  - すべての値を文字列（String）で保持
  - `@Domain` アノテーションによるバリデーション
  
- **DTO**：内部処理のためのデータ構造を提供
  - 適切なデータ型（Integer, Date など）で値を保持
  - バリデーションアノテーションなし
  - ビジネスロジックで扱いやすい構造

## 5. 開発ガイドライン

### 5.1 コード作成の原則

- 新しいコード値を追加する場合は、`CodeEnum`を実装した列挙型を作成
- バリデーションルールは`domain`パッケージで一元的に定義
- 外部入力のマッピングには必ず`Form`クラスを使用
- レイヤー間のデータ受け渡しには`DTO`を使用

### 5.2 バリデーションの扱い

- 入力値のバリデーションは`Form`クラスで行う
- ドメインルールに基づくバリデーションは`@Domain`アノテーションで参照
- 複合的なバリデーションロジックはドメイン層で実装

### 5.3 REST APIの設計

- URIはリソース指向で設計
- HTTPメソッドを適切に使い分ける（GET, POST, PUT, DELETE）
- レスポンスには適切なHTTPステータスコードを設定

## 6. アンチパターン

- Formクラスをビジネスロジック内で直接使用しない
- DTOクラスにバリデーションロジックを含めない
- Action層に複雑なビジネスロジックを実装しない
- コード値を文字列リテラルでハードコードしない

## 7. テスト方針

- 単体テストでは各レイヤーを適切にモック化
- 統合テストではリクエスト～レスポンスの一連の流れをテスト
- テストデータはテスト用のSQLファイルで管理

以上のガイドラインに従うことで、保守性が高く、一貫性のあるNablarchアプリケーションの開発が可能になります。
````


Made changes.

copilot-instructions.mdファイルを作成し、今回の会話内容に基づいて詳細なガイドラインを記述しました。このファイルは、GitHubリポジトリのカスタム命令として機能し、Nablarchアプリケーションの設計思想や責務配置について開発者に指針を提供します。

ガイドラインの主な内容は以下のとおりです：

1. **Nablarchフレームワークの概要** - 基本的な説明と目的
2. **アプリケーションの基本構造と責務配置** - 主要なレイヤー構造と補完的なパッケージ構造
3. **各パッケージの役割と使い分け** - code、domain、dto、formなどの詳細な説明と実装例
4. **処理フローと使い分けの意図** - リクエスト処理の流れとFormとDTOの使い分け
5. **開発ガイドライン** - コード作成の原則、バリデーションの扱い、REST API設計の指針
6. **アンチパターン** - 避けるべき設計パターンの例
7. **テスト方針** - テスト実装のアプローチ

このファイルをリポジトリのルートディレクトリに配置することで、GitHub Copilotはこの設計指針に従ったコード生成や提案を行うようになります。また、新しい開発者がプロジェクトに参加した際に、アーキテクチャの概要を素早く理解するための参考資料としても活用できます。

必要に応じて、このガイドラインに具体的な実装例やプロジェクト固有のルールを追加することで、さらに実用的な指針にすることができます。
